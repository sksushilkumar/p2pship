#summary Instructions on using the SIP interface

= Introduction =

The SIP interface provides SIP-based applications with peer-to-peer communication. Currently it supports
 
 * Media sessions (INVITEs with media parameters)
 * Instant messaging (MESSAGE)

The proxy will act as a media proxy for media sessions if necessary (when the application itself does not support a good [HIP] transport protocol).

It can also act as a router (gateway) for calls destined for outside the peer-to-peer system, for instance for SIP-to-POTS proxies.

The SIP subsystem features also message filtering (SPAM/SPIT control).

== Requirements ==

The SIP interface (or subsystem) has to be enabled when compiling the source. This is the default, but can also be explicitly stated during configure with
{{{ 
./configure --enable-sip 
}}}

This requires the osip library to be installed with development files. Version 2 of osip has generally been used by the authors, although version 3 is also supported (as it is used with Maemo). On debian-based systems, this can be installed with
{{{
apt-get install libosip2-dev
}}}

= Configuring =

The core SIP system requires few settings; the local port on which the SIP proxy will be running as well as the behaviour of the media proxy.

See [Configuration#SIP SIP-related configuration values]

The most important are:
 
 * `sip_proxy_ifaces` - The interface on which the SIP proxy resides (`lo` is a good choice, `ext` is a wildcard for all externally-facing interfaces).
 * `sip_proxy_port` - The port on which the SIP proxy listens to

By default, the proxy listens to both TCP and UDP SIP traffic. UDP has been in use the most (and might therefore be a bit stabler), but TCP should work fine. TCP may also be needed for certain types of traffic, such as large image IM messages.

= Use =

Configure your SIP UA to use the p2pship proxy for all SIP traffic. By default this is on the localhost interface, port 1234.

= Access control =

See [Configuration#Access_Control Access control- related configuration values]

= SIP Gateway =

See the [SIPGateway page about the gateway] feature as well as [Configuration#Gateway SIP gateway- related configuration values]

= Hooks =

Brief overview of how _hooks_ can be planted into the SIP subsystem. This is for developers of the system or of extensions only!

== Client handlers ==

Client handlers are applications that process SIP messages *right* before the messages would be sent to the *local* SIP UA.  That is, after the SIP message (either a remotely got or a response generated by the proxy) has gone through the normal mangling, it is run through the SIP client handlers.  These may _capture_ the message, i.e., prevent it from being sent, or just record it, modify it, for whatever purpose.

The idea with having a hook this late in the chain is that the plug-ins can leverage all the normal access control, processing and media proxying of the proxy (which has already been completed). They (can) act therefore, as fairly normal SIP UAs!

The current primary use for these is the [Multiparty multiparty] conferencing extensions. These piggyback on normal accounts, using _name+conference@domain_ addressing. But as said, this can be used also as a filter for messages to the normal SIP UAs, for instance for accounting or content filtering.

The client handlers are fairly simple. Once one is registered, ALL messages go through it. In the [PRE python environment], there's a dedicated 'singleton' client handler in the sip.py library. Scripts should not call the client handler registration themselves, but use the Python IPC to register for receiving messages for specific users. This is done using the `sip_client_install()` function of the sip.py library.

*Note:* This is considered slightly depricated as the same feature (modifying content and capturing messages can now be done through the request handlers).

== Request handlers ("post processors") ==

These are similar to the client handlers, but called *after* the message processing of the sipp module. They are essentially extensions for the message processing.

These are run both for locally and remotely got signalling, as well as injected packets. The post processors are able to modify the message content as well as indicate what sort of response code (if any) should be returned. They cannot modify the contents of the response message, so in practice if that is needed, they should prevent one from being sent and inject a custom response message into the system.

In PRE, these should be used similarly to the client handlers (through a sip.py singleton).

== Access control filters ==

The access control filters access the SIP messages before any type of mangling. There are separate queues for local and remote messages. These are run always *before* the message enters the sip processing. And only on external (local/remote UA), not responses etc generated by the proxy itself.

In the PRE, these can currently only indicate whether to stop the message, not modify the content. In practice however, plugins can capture the message and inject a new, slightly modified one.

Currently access control filters are used for trust filtering, black and whitelists, as well as for the voicemail, where it is essential that certain (busy, not available responses) messages do not go through the loops as it would tear down the mediaproxies and other state needed for recording the messages.

== Message injection ==

Messages can be injected using the `sipp_inject_local_message()` and `sipp_inject_remote_message()` calls. These will be handled just as locally/remotely got messages, except that the caller is able to indicate whether they should be subjected to the filtering process. These will also be tagged as 'internally generated', which can be used by filters and post-processors to identify messages they've generated themselves. In PRE, these are called using the `route_as_local` and `route_as_remote` calls, which are more easily used by calling the `SipMessage` class' `send(as_remote = True/False, filter = True/False)`.