#summary Instructions on using the SIP interface

= Introduction =

The SIP interface provides SIP-based applications with peer-to-peer communication. Currently it supports
 
 * Media sessions (INVITEs with media parameters)
 * Instant messaging (MESSAGE)

The proxy will act as a media proxy for media sessions if necessary (when the application itself does not support a good [HIP] transport protocol).

It can also act as a router (gateway) for calls destined for outside the peer-to-peer system, for instance for SIP-to-POTS proxies.

The SIP subsystem features also message filtering (SPAM/SPIT control).

== Requirements ==

The SIP interface (or subsystem) has to be enabled when compiling the source. This is the default, but can also be explicitly stated during configure with
{{{ 
./configure --enable-sip 
}}}

This requires the osip library to be installed with development files. Version 2 of osip has generally been used by the authors, although version 3 has been tried successfully in the past. On debian-based systems, this can be installed with
{{{
apt-get install libosip2-dev
}}}

= Configuring =

The core SIP system requires few settings; the local port on which the SIP proxy will be running as well as the behaviour of the media proxy.

See [Configuration#SIP SIP-related configuration values]

= Use =

_todo_

= Access control =

_todo_

See [Configuration#Access_Control Access control- related configuration values]

= SIP Gateway =

See the [SIPGateway page about the gateway] feature as well as [Configuration#Gateway SIP gateway- related configuration values]


= Hooks =

Brief overview of how _hooks_ can be planted into the SIP subsystem.

== Client handlers ==

Client handlers are applications that process SIP messages *right* before the messages would be sent to the *local* SIP UA.  That is, after the SIP message (either a remotely got or a response generated by the proxy) has gone through the normal mangling, it is run through the SIP client handlers.  These may _capture_ the message, i.e., prevent it from being sent, or just record it, modify it, for whatever purpose.

The idea with having a hook this late in the chain is that the plug-ins can leverage all the normal access control, processing and media proxying of the proxy (which has already been completed). They (can) act therefore, as fairly normal SIP UAs!

The current primary use for these is the [Multiparty multiparty] conferencing extensions. These piggyback on normal accounts, using _name+conference@domain_ addressing.

The client handlers are fairly simple. Once one is registered, ALL messages go through it. In the [PRE python environment], there's a dedicated 'singleton' client handler in the sip.py library. Scripts should not call the client handler registration themselves, but use the Python IPC to register for receiving messages for specific users. This is done using the `sip_client_install()` function of the sip.py library.

== Request handlers ("post processors") ==

These are similar to the client handlers, but called *after* the message processing of the sipp module. They are essentially extensions for the message processing.

Currently only for local request / responses (as remote ones would be caught by the client handlers anyway). They cannot modify the response content any request may lead to (also done by the client handlers), but they can indicate what sort of response (error code), if any, should be returned.


== Access control filters ==

The access control filters access the SIP messages before any type of mangling. There are separate queues for local and remote messages. These are run always *before* the message enters the sip processing. And only on external (local/remote UA), not responses etc generated by the proxy itself.